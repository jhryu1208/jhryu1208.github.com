/*!
 * Chirpy v6.3.1 | Â© 2019 Cotes Chung | MIT Licensed | https://github.com/cotes2020/jekyll-theme-chirpy/
 */

(function () {
  'use strict';

  /**
   * Reference: https://bootsnipp.com/snippets/featured/link-to-top-page
   */

  function back2top() {
    const $window = $(window);
    const $btn = $('#back-to-top');
    $window.on('scroll', () => {
      if ($window.scrollTop() > 50) {
        $btn.fadeIn();
      } else {
        $btn.fadeOut();
      }
    });
    $btn.on('click', () => {
      $window.scrollTop(0);
    });
  }

  /**
   * Initial Bootstrap Tooltip.
   */
  function loadTooptip() {
    const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]');
    [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl));
  }

  function basic() {
    back2top();
    loadTooptip();
  }

  /**
   * Add listener for theme mode toggle
   */
  const $toggleElem = $('.mode-toggle');
  function modeWatcher() {
    if ($toggleElem.length === 0) {
      return;
    }
    $toggleElem.off().on('click', e => {
      const $target = $(e.target);
      let $btn = $target.prop('tagName') === 'button'.toUpperCase() ? $target : $target.parent();
      modeToggle.flipMode(); // modeToggle: `_includes/mode-toggle.html`
      $btn.trigger('blur'); // remove the clicking outline
    });
  }

  function _toPrimitive(t, r) {
    if ("object" != typeof t || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != typeof i) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  function _toPropertyKey(t) {
    var i = _toPrimitive(t, "string");
    return "symbol" == typeof i ? i : String(i);
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  /**
   * Expand or close the sidebar in mobile screens.
   */

  const $body = $('body');
  const ATTR_DISPLAY = 'sidebar-display';
  class SidebarUtil {
    static toggle() {
      if (SidebarUtil.isExpanded === false) {
        $body.attr(ATTR_DISPLAY, '');
      } else {
        $body.removeAttr(ATTR_DISPLAY);
      }
      SidebarUtil.isExpanded = !SidebarUtil.isExpanded;
    }
  }
  _defineProperty(SidebarUtil, "isExpanded", false);
  function sidebarExpand() {
    $('#sidebar-trigger').on('click', SidebarUtil.toggle);
    $('#mask').on('click', SidebarUtil.toggle);
  }

  function initSidebar() {
    modeWatcher();
    sidebarExpand();
  }

  /**
   * This script make #search-result-wrapper switch to unloaded or shown automatically.
   */
  const $btnSbTrigger = $('#sidebar-trigger');
  const $btnSearchTrigger = $('#search-trigger');
  const $btnCancel = $('#search-cancel');
  const $content = $('#main-wrapper>.container>.row');
  const $topbarTitle = $('#topbar-title');
  const $search = $('search');
  const $resultWrapper = $('#search-result-wrapper');
  const $results = $('#search-results');
  const $input = $('#search-input');
  const $hints = $('#search-hints');
  const $viewport = $('html,body');

  // class names
  const C_LOADED = 'loaded';
  const C_UNLOADED = 'unloaded';
  const C_FOCUS = 'input-focus';
  const C_FLEX = 'd-flex';
  class ScrollBlocker {
    static on() {
      ScrollBlocker.offset = window.scrollY;
      $viewport.scrollTop(0);
    }
    static off() {
      $viewport.scrollTop(ScrollBlocker.offset);
    }
  }

  /*--- Actions in mobile screens (Sidebar hidden) ---*/
  _defineProperty(ScrollBlocker, "offset", 0);
  _defineProperty(ScrollBlocker, "resultVisible", false);
  class MobileSearchBar {
    static on() {
      $btnSbTrigger.addClass(C_UNLOADED);
      $topbarTitle.addClass(C_UNLOADED);
      $btnSearchTrigger.addClass(C_UNLOADED);
      $search.addClass(C_FLEX);
      $btnCancel.addClass(C_LOADED);
    }
    static off() {
      $btnCancel.removeClass(C_LOADED);
      $search.removeClass(C_FLEX);
      $btnSbTrigger.removeClass(C_UNLOADED);
      $topbarTitle.removeClass(C_UNLOADED);
      $btnSearchTrigger.removeClass(C_UNLOADED);
    }
  }
  class ResultSwitch {
    static on() {
      if (!ScrollBlocker.resultVisible) {
        // the block method must be called before $(#main-wrapper>.container) unloaded.
        ScrollBlocker.on();
        $resultWrapper.removeClass(C_UNLOADED);
        $content.addClass(C_UNLOADED);
        ScrollBlocker.resultVisible = true;
      }
    }
    static off() {
      if (ScrollBlocker.resultVisible) {
        $results.empty();
        if ($hints.hasClass(C_UNLOADED)) {
          $hints.removeClass(C_UNLOADED);
        }
        $resultWrapper.addClass(C_UNLOADED);
        $content.removeClass(C_UNLOADED);

        // now the release method must be called after $(#main-wrapper>.container) display
        ScrollBlocker.off();
        $input.val('');
        ScrollBlocker.resultVisible = false;
      }
    }
  }
  function isMobileView() {
    return $btnCancel.hasClass(C_LOADED);
  }
  function displaySearch() {
    $btnSearchTrigger.on('click', function () {
      MobileSearchBar.on();
      ResultSwitch.on();
      $input.trigger('focus');
    });
    $btnCancel.on('click', function () {
      MobileSearchBar.off();
      ResultSwitch.off();
    });
    $input.on('focus', function () {
      $search.addClass(C_FOCUS);
    });
    $input.on('focusout', function () {
      $search.removeClass(C_FOCUS);
    });
    $input.on('input', () => {
      if ($input.val() === '') {
        if (isMobileView()) {
          $hints.removeClass(C_UNLOADED);
        } else {
          ResultSwitch.off();
        }
      } else {
        ResultSwitch.on();
        if (isMobileView()) {
          $hints.addClass(C_UNLOADED);
        }
      }
    });
  }

  function initTopbar() {
    displaySearch();
  }

  /**
   * Tab 'Categories' expand/close effect.
   */
  $('.collapse');

  /**
   * Clipboard functions
   *
   * Dependencies:
   *   - popper.js (https://github.com/popperjs/popper-core)
   *   - clipboard.js (https://github.com/zenorocha/clipboard.js)
   */

  const clipboardSelector = '.code-header>button';
  function getIcon(btn) {
    let iconNode = $(btn).children();
    return iconNode.attr('class');
  }
  getIcon(clipboardSelector);

  /**
   * Setting up image lazy loading and LQIP switching
   */

  const ATTR_DATA_SRC = 'data-src';
  const ATTR_DATA_LQIP = 'data-lqip';
  const cover = {
    SHIMMER: 'shimmer',
    BLUR: 'blur'
  };
  function removeCover(clzss) {
    $(this).parent().removeClass(clzss);
  }
  function handleImage() {
    if (!this.complete) {
      return;
    }
    if (this.hasAttribute(ATTR_DATA_LQIP)) {
      removeCover.call(this, cover.BLUR);
    } else {
      removeCover.call(this, cover.SHIMMER);
    }
  }

  /**
   * Switches the LQIP with the real image URL.
   */
  function switchLQIP() {
    const $img = $(this);
    const src = $img.attr(ATTR_DATA_SRC);
    $img.attr('src', encodeURI(src));
    $img.removeAttr(ATTR_DATA_SRC);
  }
  function loadImg() {
    const $images = $('article img');
    if ($images.length) {
      $images.on('load', handleImage);
    }

    // Images loaded from the browser cache do not trigger the 'load' event
    $('article img[loading="lazy"]').each(function () {
      if (this.complete) {
        removeCover.call(this, cover.SHIMMER);
      }
    });

    // LQIPs set by the data URI or WebP will not trigger the 'load' event,
    // so manually convert the URI to the URL of a high-resolution image.
    const $lqips = $("article img[".concat(ATTR_DATA_LQIP, "=\"true\"]"));
    if ($lqips.length) {
      $lqips.each(switchLQIP);
    }
  }

  /**
   * Update month/day to locale datetime
   *
   * Requirement: <https://github.com/iamkun/dayjs>
   */

  /* A tool for locale datetime */
  class LocaleHelper {
    static get attrTimestamp() {
      return 'data-ts';
    }
    static get attrDateFormat() {
      return 'data-df';
    }
    static get locale() {
      return $('html').attr('lang').substring(0, 2);
    }
    static getTimestamp(elem) {
      return Number(elem.attr(LocaleHelper.attrTimestamp)); // unix timestamp
    }
    static getDateFormat(elem) {
      return elem.attr(LocaleHelper.attrDateFormat);
    }
  }
  function initLocaleDatetime() {
    dayjs.locale(LocaleHelper.locale);
    dayjs.extend(window.dayjs_plugin_localizedFormat);
    $("[".concat(LocaleHelper.attrTimestamp, "]")).each(function () {
      const date = dayjs.unix(LocaleHelper.getTimestamp($(this)));
      const text = date.format(LocaleHelper.getDateFormat($(this)));
      $(this).text(text);
      $(this).removeAttr(LocaleHelper.attrTimestamp);
      $(this).removeAttr(LocaleHelper.attrDateFormat);

      // setup tooltips
      const tooltip = $(this).attr('data-bs-toggle');
      if (typeof tooltip === 'undefined' || tooltip !== 'tooltip') {
        return;
      }
      const tooltipText = date.format('llll'); // see: https://day.js.org/docs/en/display/format#list-of-localized-formats
      $(this).attr('data-bs-title', tooltipText);
      new bootstrap.Tooltip($(this));
    });
  }

  basic();
  initSidebar();
  initTopbar();
  initLocaleDatetime();
  loadImg();

})();
//# sourceMappingURL=home.min.js.map
